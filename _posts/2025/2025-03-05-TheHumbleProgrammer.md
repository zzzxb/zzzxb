---
layout: post
title: "谦卑的程序员"
date: 2025-03-05 18:34:00 +0800
tag: Praise
---

* content
{:toc}

由于一连串的巧合，我在1952年春天的第一个早晨正式进入编程行业，据我所知，我是第一个在我的国家从事编程行业的荷兰人。回想起来，最令人惊奇的是，至少在我这个地区，编程行业出现的速度很慢，这种速度现在很难相信。但我很感激那个时期的两个生动的回忆，这些回忆毫无疑问地确立了这种缓慢。

在编程了大约三年后，我与A. van Wijngaarden进行了讨论，他当时是我在阿姆斯特丹数学中心的老板，只要我活着，我将继续感谢他。重点是，我应该同时在莱顿大学学习理论物理学，当我发现这两种活动越来越难结合时，我不得不下定决心，要么停止编程，成为一名真正、受人尊敬的理论物理学家，要么只用最少的努力正式完成我的物理学研究，然后成为......，是的，什么？程序员？但那是一个受人尊敬的职业吗？毕竟，编程是什么？哪里有健全的知识体系可以支持它作为一门智力上受人尊敬的学科？我清楚地记得我是多么羡慕我的硬件同事，当被问及他们的专业能力时，他们至少可以指出他们了解真空管、放大器和其他一切，而我觉得，当面对这个问题时，我会空手而出。我满怀疑虑地敲了敲van Wijngaarden的办公室门，问他是否可以“和他聊一会儿”；几个小时后，当我离开他的办公室时，我是另一个人。因为在耐心地听取了我的问题后，他同意，直到那一刻，编程纪律并不多，但随后他继续悄悄地解释说，自动计算机会一直存在，我们才刚刚开始，我不能成为未来几年被召唤使编程成为受人尊敬的纪律的人之一吗？这是我人生的转折点，我尽可能快地正式完成了物理学的学习。当然，上述故事的一个寓意是，当我们给年轻人提供建议时，我们必须非常小心；有时他们也会遵循建议！

又两年后，即1957年，我结婚了，荷兰的婚姻仪式要求你陈述你的职业，我声明我是一名程序员。但阿姆斯特丹镇的市政当局不接受，理由是没有这种职业。而且，信不信由你，在“职业”的标题下，我的婚姻法案显示了荒谬的条目“理论物理学家”！

我看到编程专业在自己的国家出现的速度太慢了。从那时起，我看到了更多的世界，我的总体印象是，在其他国家，除了可能的日期转移外，增长模式也大相同。

让我试着更详细地捕捉过去的情况，希望能更好地了解今天的情况。当我们继续分析时，我们将看到有多少关于编程任务真实性质的常见误解可以追溯到现在遥远的过去。

第一批自动电子计算机都是独特的单复印机，它们都可以在具有实验实验室令人兴奋的氛围的环境中找到。一旦自动计算机的愿景出现，它的实现对当时可用的电子技术来说是一个巨大的挑战，有一点是肯定的：我们不能否认那些决定尝试建造如此奇妙设备的团体的勇气。对于奇妙的设备来说，它们是：回想起来，人们只能怀疑那些第一批机器是否工作，至少有时是这样。压倒性的问题是让机器保持工作正常。对自动计算物理方面的关注仍然反映在该领域较老的科学协会的名称中，如计算机协会或英国计算机协会，这些名称明确提到了物理设备。

那个糟糕的程序员呢？好吧，说实话：他几乎没有被注意到。首先，第一台机器太笨重了，你几乎无法移动它们，此外，它们需要如此广泛的维护，以至于人们尝试使用机器的地方是机器开发的同一个实验室，这是很自然的。其次，他有些看不见的作品没有任何魅力：你可以向游客展示机器，这比一些编码表要壮观几个数量级。但最重要的是，程序员本人对自己的工作有非常谦虚的看法：他的工作从那台奇妙的机器的存在中获得了所有意义。因为那是一台独特的机器，他非常清楚他的程序只有当地意义，而且，很明显，这台机器的寿命有限，他知道他的作品很少会具有持久的价值。最后，还有另一种情况对程序员对工作的态度产生了深远的影响：一方面，除了不可靠之外，他的机器通常太慢，内存通常也太小，即他面临着一个夹鞋，而另一方面，它通常有点奇怪的订单代码将满足最意想不到的结构。在那些日子里，许多聪明的程序员从狡猾的伎俩中获得了巨大的智力满足感，他通过这些伎俩将不可能的事情挤入他设备的约束中。

关于那些日子的编程日期的两种意见。我现在提到他们，我稍后再说。一种观点是，一个真正有能力的程序员应该有困惑的头脑，并且非常喜欢巧妙的技巧；另一种观点是，编程无非是优化计算过程的效率，无论方向还是另一个方向。

后一种观点是经常出现的情况的结果，事实上，可用的设备是一个痛苦的挤压，在那些日子里，人们经常会遇到天真的期望，即一旦有更强大的机器可用，编程将不再是一个问题，因为那时将机器推到极限的斗争将不再必要，这就是编程的全部内容，不是吗？但在接下来的几十年里，发生了完全不同的事情：更强大的机器变得可用，不仅仅是一个数量级的机器，甚至更强大几个数量级的机器。但是，我们发现自己处于解决所有编程问题的永恒幸福状态，而是发现自己在软件危机中陷入困境！怎么会呢？

有一个小原因：从一两个方面来说，现代机械基本上比旧机械更难操作。首先，我们有I/O中断，发生在不可预测和不可逆转的时刻；与假装是完全确定性的自动机的旧顺序机器相比，这是一个戏剧性的变化，许多系统程序员的白发证明了一个事实，即我们不应该轻描淡写地谈论该功能造成的逻辑问题。其次，我们拥有配备了多级商店的机器，向我们提出了管理策略的问题，尽管有关于该主题的大量文献，但仍然相当难以捉摸。由于实际机器的结构变化，增加了复杂性。

但我称这是一个次要原因；主要原因是......机器变得强大了几个数量级！直截了当地说：只要没有机器，编程就根本不是问题；当我们有几台弱小的计算机时，编程就变成了一个温和的问题，现在我们有了巨大的计算机，编程也成了一个同样巨大的问题。从这个意义上说，电子行业没有解决任何问题，它只是创造了它们，它创造了使用其产品的问题。用另一种方式说：随着可用机器的力量增长了一千倍以上，社会应用这些机器的野心成比例地增长了，正是这个贫穷的程序员在这个目的和手段之间紧张的领域找到了工作。硬件的功率增加，加上其可靠性的更大幅度提高，使程序员几年前不敢梦想的解决方案变得可行。现在，几年后，他不得不梦想着它们，更糟糕的是，他不得不把这些梦想变成现实！我们发现自己处于软件危机中，这很神奇吗？不，当然不是，正如你可能猜到的那样，它甚至被提前预言了；但当然，小先知的麻烦在于，直到五年后，你才真正知道他们是对的。

然后，在六十年代中期，发生了一件可怕的事情：所谓的第三代计算机出现了。官方文献告诉我们，他们的性价比一直是主要的设计目标之一。但是，如果您将机器各种组件的工作周期视为“性能”，很少能阻止您最终产生一个设计，其中您的性能目标的主要部分是通过必要性可疑的内部家务活动来实现的。如果您对价格的定义是为硬件支付的价格，那么很少能阻止您最终获得一个非常难以编程的设计：例如，订单代码可能会对程序员或系统强制执行早期具有约束力的决定，这些决定确实无法解决的冲突。在很大程度上，这些不愉快的可能性似乎已经成为现实。

当这些机器被宣布并知道它们的功能规格时，我们中的一些人一定变得相当痛苦；至少我是。期望这种机器会充斥着计算机界是合理的，因此，它们的设计应该尽可能健全，这一点更加重要。但该设计体现了如此严重的缺陷，以至于我觉得计算科学的进步被推迟了至少十年：就在那时，我度过了整个职业生涯中最黑暗的一周。也许现在最令人难过的是，即使经历了这么多年令人沮丧的经历，仍然有很多人真诚地相信，某种自然法则告诉我们，机器必须是这样的。他们通过观察这些机器中有多少已经售出来平息他们的疑虑，并从这种观察中得出错误的安全感，毕竟，设计不可能那么糟糕。但仔细观察后，这种防线与吸烟一定是健康的论点一样具有说服力，因为吸烟的人太多了。

在这方面，我很遗憾，计算领域的科学期刊以我们审查科学出版物的方式发表新发布的计算机评论并不习惯：审查机器至少同样重要。在这里，我要坦白一件事：在六十年代初，我写了这样一篇评论，打算把它提交给CACM，但尽管文本被发送给建议的少数同事敦促我这样做，但我不敢这样做，因为担心对我自己或编辑委员会来说，困难会太大。这种压制是我这边的懦弱行为，我为此越来越责怪自己。我所看到的困难是缺乏普遍接受的标准的结果，虽然我确信我选择适用的标准是有效的，但我担心我的评论会被拒绝或作为“个人品味问题”而放弃。我仍然认为这种评论会非常有用，我渴望看到它们出现，因为它们被接受的出现将是计算界成熟的肯定标志。

我之所以对硬件场景给予上述关注，是因为我觉得任何计算工具最重要的方面之一就是它对那些试图使用它的人的思维习惯的影响，而且我有理由相信这种影响比通常假设的要强很多倍。现在让我们把注意力转向软件场景。

这里的多样性如此之大，以至于我必须把自己限制在几个垫脚石上。我痛苦地意识到我的选择是武断的，我求你不要就我对许多努力的赞赏得出任何结论，这些努力将没有被提及。

起初，英国剑桥有EDSAC，我认为从一开始，子例程库的概念就在机器的设计及其使用方式中发挥了核心作用，这令人印象深刻。近25年后，计算场景发生了巨大变化，但基本软件的概念仍然存在，封闭子程序的概念仍然是编程的关键概念之一。我们应该认识到封闭的子例程是最伟大的软件发明之一；它在三代计算机中幸存下来，并且还将存活几代，因为它满足了我们基本抽象模式之一的实现。令人遗憾的是，它在第三代计算机的设计中的重要性被低估了，其中大量的算术单元的明确命名寄存器意味着子例程机制的大量开销。但即使这样，也并没有扼杀子例程的概念，我们只能祈祷突变不会被证明是遗传的。

我想提到的软件领域的第二个主要发展是FORTRAN的诞生。当时，这是一个非常无度的项目，负责它的人值得我们大大钦佩。仅仅因为十年左右广泛使用后才变得明显的缺点归咎于他们绝对不公平：成功展望十年的团体非常罕见！回想起来，我们必须将FORTRAN评为一种成功的编码技术，但由于很少有有效的构思辅助工具，现在迫切需要这些辅助工具，是时候考虑它已经过时了。我们越早忘记FORTRAN曾经存在过，越好，因为作为一种思想载体，它不再足够：它浪费了我们的脑力，风险太大，因此使用起来太贵了。FORTRAN的悲惨命运是它被广泛接受，在精神上将成千上万的程序员束缚在我们过去的错误中。我每天都祈祷，希望更多的程序员同事能找到从兼容性的诅咒中解放出来的方法。

我不想不提的第三个项目是LISP，这是一个性质完全不同的迷人企业。凭借其基础上的一些非常基本的原则，它显示出了非凡的稳定性。除此之外，从某种意义上说，LISP一直是我们最复杂的计算机应用程序的载体。LISP被开玩笑地描述为“滥用计算机的最智能方式”。我认为这种描述是一个很大的赞美，因为它传达了解放的全部味道：它帮助我们一些最有天赋的同胞思考以前不可能的想法。

第四个要提到的项目是ALGOL 60。虽然直到今天，FORTRAN程序员仍然倾向于从他们正在使用的具体实现的角度来理解他们的编程语言——因此八进制和十六进制转储的盛行——虽然LISP的定义仍然是语言的含义和机制如何工作的奇怪混合，但著名的算法语言ALGOL 60报告是真正努力的成果，将抽象进一步推进，并以独立于实现的方式定义编程语言。可以争辩说，在这方面，其作者非常成功，以至于他们对它是否能够实施产生了严重的怀疑！该报告光荣地展示了形式方法BNF的力量，现在被称为Backus-Naur-Form，以及精心措辞的英语的力量，至少当像Peter Naur这样聪明的人使用时。我认为可以公平地说，只有极少数像这样简短的文件对计算界产生了同样深远的影响。在后来的几年里，ALGOL和ALGOL-like的名字很容易被用作一个不受保护的商标，将其一些有时几乎不相关的年轻项目所借用一些荣耀，这对其地位的某种程度令人震惊的赞美。BNF作为定义设备的优势是我认为该语言的弱点之一的原因：一个过于详细且不太系统的语法现在可以塞进很少的页面的范围内。有了像BNF一样强大的设备，关于算法语言ALGOL 60的报告应该要短得多。除此之外，我对ALGOL 60的参数机制非常怀疑：它允许程序员如此多的组合自由，以至于自信地使用它需要程序员的严格纪律。除了昂贵的实施外，使用起来似乎很危险。

最后，虽然这个主题并不令人愉快，但我必须提到PL/1，这是一种编程语言，其定义文档的规模和复杂性令人恐惧。使用PL/1必须像驾驶一架有7000个按钮、开关和手柄在驾驶舱中操作的飞机一样。我绝对看不出，当编程语言——我们的基本工具，注意！——已经摆脱了我们的智力控制时，我们如何能够将我们不断增长的程序牢牢地保持在我们的智力控制之下。如果我必须描述PL/1对其用户的影响，我想到的最接近的隐喻是药物。我记得在一次关于高级编程语言的研讨会上，一位自称是PL/1忠实用户之一的人为PL/1辩护的演讲。但在一小时的演讲中，他设法要求增加大约50个新的“功能”，几乎没有假设他问题的主要来源很可能是它已经包含了太多的“功能”。演讲者表现出成瘾的所有令人沮丧的症状，因为他处于精神停滞的状态，他只能要求更多、更多、更多......当FORTRAN被称为婴儿疾病时，全PL/1具有危险肿瘤的生长特征，可能会变成一种致命的疾病。

过去这么多。但是，除非我们之后能够从中吸取教训，否则犯错是没有意义的。事实上，我认为我们学到了很多，在几年内，编程可以成为一项与到目前为止大不相同的活动，如此不同，以至于我们最好为震惊做好准备。让我为你勾勒一个可能的未来。乍一看，这种也许在不久的将来的编程愿景可能已经让你非常奇妙。因此，让我也补充一下可能导致人们得出结论的考虑因素，即这个愿景可能是一个非常真实的可能性。

愿景是，在七十年代完成之前，我们将能够设计和实施现在使我们的编程能力紧张的那种系统，而成本仅占我们现在成本的百分之几，除此之外，这些系统将几乎没有错误。这两个改进是相得的。在后一个方面，软件似乎与许多其他产品不同，通常质量越高意味着价格越高。那些想要真正可靠的软件的人会发现，他们必须找到避免大多数错误的方法，因此编程过程将变得更便宜。如果你想要更有效的程序员，你会发现他们不应该浪费调试时间，他们不应该一开始就引入错误。换句话说：两个目标都指向相同的变化。

在如此短的时间内发生如此剧烈的变化将是一场革命，对于所有将对未来的期望建立在对最近过去的顺利推断的基础上的人——上诉于一些不成文的社会和文化惯性规律——这种急剧变化发生的机会似乎可以忽略不计。但我们都知道，有时革命确实发生了！这个机会有多大？

似乎有三个主要条件必须满足。整个世界必须认识到变革的必要性；其次，对变革的经济需求必须足够强烈；第三，变革必须在技术上是可行的。让我按照上述顺序讨论这三个条件。

关于对软件更高可靠性需求的认识，我预计不会再有异议。就在几年前，这就不一样了：谈论软件危机是亵渎神明。转折点是1968年10月在加米施举行的软件工程会议，这次会议在软件危机的首次公开承认发生时引起了轰动。现在人们普遍认为，任何大型复杂系统的设计都将是一项非常困难的工作，每当遇到负责此类工作的人时，就会发现他们非常关注可靠性问题，这是正确的。简而言之，我们的第一个条件似乎得到了满足。

现在为了经济需求。如今，人们经常会遇到这样的看法：在六十年代，编程是一个高薪职业，预计未来几年程序员的工资可能会下降。通常，这种观点是与经济衰退有关表达的，但这可能是一些不同且相当健康的症状，即也许过去十年的程序员没有像他们应该做的那样做得很好。社会对程序员及其产品的表现越来越不满意。但还有另一个更重要的因素。在目前的情况下，对于一个特定的系统来说，为软件开发支付的代价与所需硬件的价格相同，社会或多或少地接受这一点是很常见的。但硬件制造商告诉我们，在未来十年，硬件价格预计将下降十倍。如果软件开发继续像现在这样笨拙和昂贵的过程，事情将完全失去平衡。你不能指望社会接受这一点，因此我们必须学会更有效地编程。用另一种方式说：只要机器是预算中最大的项目，编程行业就可以摆脱其笨拙的技术，但这个保护伞会迅速折叠。简而言之，我们的第二个条件似乎也得到了满足。

现在第三个条件：在技术上是否可行？我认为可能会，我会给你六个支持这个观点的论据。

对程序结构的研究表明，程序——即使是具有相同任务和相同数学内容的替代程序——在智力可管理性方面也会有很大不同。已经发现了一些规则，违反这些规则将严重损害或完全破坏程序的智力可管理性。这些规则有两种。第一种很容易被机械地强加，即通过适当选择的编程语言。例如，排除goto-statements和具有多个输出参数的过程。对于第二类，我至少——但这可能是由于我缺乏能力——认为没有办法机械地强加它们，因为它似乎需要某种我没有存在证明的自动定理证明。因此，就目前而言，也许永远而言，第二种规则是程序员要求的纪律要素。我心中的一些规则非常明确，以至于可以教授它们，并且永远不需要争论给定的程序是否违反了这些规则。例如，在没有提供终止证明或说明不变性不会因执行可重复语句而破坏的关系的情况下，不应将任何循环写入。

我现在建议我们把自己限制在设计和实施智力上可管理的程序上。如果有人担心这种限制太严格了，以至于我们无法忍受它，我可以向他保证：智力上可管理的程序类别仍然足够丰富，可以包含许多非常现实的程序，以解决任何能够解决算法的问题。我们绝不能忘记，制作程序不是我们的事，而是设计能够显示所需行为的计算类是我们的事。把自己限制在智力上可管理的程序的建议是我宣布的六个论点中前两个的基础。

论点之一是，由于程序员只需要考虑在智力上可管理的程序，他选择的替代方案要容易得多。

论点二是，一旦我们决定将自己限制在智力上可管理程序的子集上，我们就一劳永逸地大幅减少了要考虑的解决方案空间。这个论点与第一论点不同。

论点三是基于对程序正确性问题的建设性方法。今天，一种常见的技术是制作一个程序，然后进行测试。但是：程序测试可以是一种非常有效的方式来显示错误的存在，但无望地不足以显示错误的存在。显著提高程序信心水平的唯一有效方法是为其正确性提供令人信服的证明。但人们不应该先制作程序，然后再证明其正确性，因为那样提供证明的要求只会增加糟糕的程序员的负担。相反：程序员应该让正确性证明和程序齐头并进。论点三基本上是基于以下观察结果。如果一个人首先问自己一个令人信服的证明的结构是什么，然后发现这一点，然后构建一个满足该证明要求的程序，那么这些正确性问题变成了一个非常有效的启发式指导。根据定义，这种方法仅适用于我们限制自己在智力上可管理的项目时，但它为我们提供了在这些项目中找到令人满意的项目的有效手段。

论点四与设计程序所需的智力努力取决于程序长度的方式有关。有人认为，有某种自然规律告诉我们，所需的智力努力随着程序长度的平方而增长。但是，谢天谢地，没有人能够证明这项法律。这是因为它不一定是真的。我们都知道，一个非常有限的推理可以涵盖无数情况的唯一心理工具被称为“抽象”；因此，有效利用他的抽象能力必须被视为一个有能力的程序员最重要的活动之一。在这方面，也许值得指出的是，抽象的目的不是模糊，而是创造一个可以绝对精确的新语义层面。当然，我试图找到一个根本原因，阻止我们的抽象机制足够有效。但无论我多么努力，我都找不到这样的原因。因此，我倾向于假设——到目前为止，经验没有反驳——通过适当应用我们的抽象力量，设想或理解一个程序所需的智力努力不需要超过程序长度成正比。但这些调查的副产品可能具有更大的实际意义，事实上，这是我第四个论点的基础。副产品是识别一些抽象模式，这些模式在编写程序的整个过程中起着至关重要的作用。现在对这些抽象模式有足够的了解，你可以专门讲授每一种抽象模式。当我意识到，如果十五年前它们是众所周知的，例如，从BNF到语法导向编译器的步骤可能需要几分钟而不是几年时，我突然意识到了对这些抽象模式的熟悉和有意识的了解意味着什么。因此，我提出我们最近对重要抽象模式的了解，作为第四个论点。

现在是第五个论点。这与我们试图使用的工具对我们自己的思维习惯的影响有关系。我观察到一种文化传统，它很可能植根于文艺复兴，忽视这种影响，将人类的思想视为其人工制品的最高和自主的主人。但是，如果我开始分析自己和人类同伴的思维习惯，无论我喜不喜欢，我都会得出一个完全不同的结论，即我们试图使用的工具以及我们用来表达或记录我们思想的语言或符号，是决定我们能思考或表达什么的主要因素！分析编程语言对其用户思维习惯的影响，并认识到到目前为止，脑力是我们最稀缺的资源，它们共同为我们提供了一套新的标准，用于比较各种编程语言的相对优点。有能力的程序员充分意识到自己头骨的严格尺寸有限；因此，他以完全谦逊的态度对待编程任务，除其他外，他避免了像瘟疫这样的巧妙伎俩。就一种众所周知的会话编程语言而言，各方都告诉我，一旦编程社区配备了终端，就会发生一个甚至有一个既定名称的特定现象：它被称为“单行本”。它有两种不同形式之一：一个程序员将一行程序放在另一个程序的桌子上，要么他自豪地讲述它的作用，并添加一个问题“你能用更少的符号编码吗？”——好像这与任何概念相关性！——要么他只是问“猜猜它的作用！”。从这一观察中，我们必须得出结论，这种语言作为一种工具，是对巧妙技巧的公开邀请；虽然这正是它的一些吸引力的解释，即对于那些喜欢展示他们有多聪明的人来说，我很抱歉，但我必须认为这是关于编程语言的最令人痛心的事情之一。我们应该从最近的过去中学到的另一个教训是，“更丰富”或“更强大”的编程语言的开发是一个错误，因为这些巴洛克怪物，这些特立独行的集团，无论是机械上还是精神上，都无法管理。我看到非常系统和非常适度的编程语言有着美好的未来。当我说“modest”时，我的意思是，例如，不仅是ALGOL 60的“for clause”，甚至FORTRAN的“DO循环”也可能发现自己因为太巴洛克式而被抛弃了。我和真正有经验的志愿者一起进行了一个小编程实验，但发生了一些意想不到的事情。我的志愿者都没有找到最明显和最优雅的解决方案。经过更仔细的分析，事实证明这有一个共同的来源：他们的重复概念与要升级的相关受控变量的想法紧密相连，以至于他们在精神上被阻止了看到显而易见的。他们的解决方案效率较低，不必要地难以理解，而且他们花了很长时间才找到它们。对我来说，这是一次启发性的经历，但也令人震惊。最后，在一个方面，人们希望明天的编程语言将与我们现在习惯的有很大不同：在比过去更大程度上，它们应该邀请我们在写下的结构中反映所有抽象，以从概念上应对我们正在设计的复杂性。我们未来工具的更大充分性就这么多了，这是第五种论点的基础。

顺便说一句，我想向那些在与当前工具不足作斗争时确定编程任务的困难的人插入一个警告，因为他们可能会得出结论，一旦我们的工具更加充分，编程将不再是一个问题。编程仍然非常困难，因为一旦我们从环境繁琐中解放出来，我们就会发现自己可以自由地解决现在远远超出我们编程能力的问题。

你可以和我的第六个论点争论，因为收集实验证据来支持它并不容易，这一事实不会阻止我相信它的有效性。到目前为止，我没有提到“层次结构”这个词，但我认为公平地说，这是所有系统的关键概念，体现了一个很好的分解解决方案。我甚至可以更进一步，从中做出一篇信仰的文章，即我们唯一能真正以令人满意的方式解决的问题是那些最终承认一个很好的因素解决方案的问题。乍一看，这种对人类局限性的看法可能让你觉得对我们困境的看法相当令人沮丧，但事实恰恰相反，我并没有这种感觉！学会与我们的局限性共存的最好方法是了解它们。当我们足够谦虚，只尝试因数分解解决方案时，因为其他努力逃脱了我们的智力控制，我们将尽最大努力避免所有这些界面损害我们以有益的方式分解系统的能力。我不能不期待这会一再导致发现，即一个最初难以解决的问题毕竟可以被考虑在内。任何见过编译阶段的大多数麻烦（称为“代码生成”）如何被追踪到订单代码的有趣属性的人，都会知道我心中的一个简单例子。精心分解的解决方案的更广泛适用性是我关于本十年可能发生的革命的技术可行性的第六个也是最后一个论点。

原则上，我让你自己决定你要对我的考虑给予多少重视，只是太清楚了，我不能强迫其他人分享我的信仰。由于每一次严肃的革命，它都会引发暴力反对，人们可以问自己，保守派势力会在哪里试图反击这种发展。我不期望他们主要在大企业，甚至在计算机业务中；我期望他们在提供当今培训的教育机构和那些认为他们的旧程序如此重要，以至于他们认为不值得重写和改进的保守的计算机用户群体中。在这方面，令人难过的是，在许多大学校园里，中央计算设施的选择往往是由一些既成熟但昂贵的应用程序的需求决定的，而忽略了有多少数千名愿意编写自己程序的“小用户”会因这种选择而受到影响的问题。例如，高能物理学似乎经常用其剩余实验设备的价格来勒索科学界。当然，最简单的答案是直接否认技术可行性，但我担心你需要非常有力的论据。唉，从今天普通程序员的智力上限将阻止革命的发生这一说中，没有任何保证：由于其他人的编程效率更高，无论如何，他都可能被排除在外。

也可能存在政治障碍。即使我们知道如何教育未来的专业程序员，也不确定我们所生活的社会是否会允许我们这样做。教授方法的第一个效果——而不是传播知识——是提高已经有能力的人的能力，从而放大智力差异。在一个教育系统被用作建立同质化文化的工具的社会中，奶油被阻止上升到顶峰，有能力的程序员的教育可能在政治上受到阻碍。

让我结束。自动计算机已经存在了我们四分之一个世纪。他们以工具的能力对我们的社会产生了巨大影响，但与人类文化史上前所未有的智力挑战能力相比，他们的影响力只是我们文化表面的涟漪。分层系统似乎具有这样一种属性，即在一个层面上被视为未分割实体的东西，在下一个更低层次的更详细程度上被视为复合对象；因此，当我们把注意力从一个层次转移到下一个较低层次时，适用于每个层次的自然空间或时间颗粒会减少一个数量级。我们用砖来理解墙壁，用晶体来理解砖，用分子来理解晶体等等。因此，在层次系统中可以有意义地区分的层次数与最大和最小粒之间比率的对数成正比，因此，除非这个比率非常大，否则我们不能期待很多层次。在计算机编程中，我们的基本构建块具有小于微秒的相关时间粒，但我们的程序可能需要几个小时的计算时间。我不知道任何其他技术覆盖了1010或以上的比率：计算机凭借其惊人的速度，似乎是第一个为我们提供了一个高度层次的人工制品既可能又必要的环境。这种挑战，即与编程任务的对抗，是如此独特，以至于这种新颖的经历可以教会我们很多关于我们自己的知识。它应该加深我们对设计和创造过程的理解，它应该让我们更好地控制组织思想的任务。如果它没有这样做，就我的口味而言，我们根本不配拥有电脑！

它已经教会了我们一些教训，我在这次演讲中选择强调的教训如下。我们将做更好的编程工作，前提是我们充分理解任务的巨大困难，只要我们坚持使用适度和优雅的编程语言，只要我们尊重人类思维的内在局限性，并以非常谦逊的程序员的身份对待任务。

* [The Humble Programmer - Edsger W. Dijkstra](https://www.cs.utexas.edu/~EWD/transcriptions/EWD03xx/EWD340.html)
